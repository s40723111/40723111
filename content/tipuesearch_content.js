var tipuesearch = {"pages": [{'title': '網路連線設定', 'text': '\n 了解機械設計系電腦輔助設計室電腦的網路設定, 其中包括 IPv4 網路與 IPv6 網路設定. \n', 'tags': '', 'url': '網路連線設定.html'}, {'title': '配置可攜程式環境', 'text': '取得 Windows 10 64 位元環境下的可攜程式環境  ( 下載\xa0 2019_cdb_w5.7z ), 下載後解開目錄, 放入 USB3.0 規格以上的隨身碟或隨身硬碟. \n 開啟start.bat即可以開啟隨身系統，以開啟stop.bat結束隨身系統 \n Y:\xa0 即切換至Y槽 \n cd ___\xa0 \xa0 切換至某目錄 \n cd ..\xa0 回至上一層目錄 \n cd / 回至目前所在槽 \n dir\xa0 \xa0列出目前所在目錄的內容 \n mkdir\xa0 在所在位置建立目錄 \n cls\xa0\xa0 清除目前的命令列顯示的內容 \n \n', 'tags': '', 'url': '配置可攜程式環境.html'}, {'title': '建立Git倉儲', 'text': '\n 建立 Git 倉儲, 共分為兩類 \n (1)\xa0 直接在 Github 網際介面下建立倉儲時, 要求建立 README.md 檔案, 之後可以直接在近端, 以 git clone 加上倉儲連線 URL, 將倉儲克隆一份到近端, 並以最新版本作為工作目錄, 使用者改版後, 可以直接透過 git add, commit 與 push 對遠端倉儲改版 \n \n (2)\xa0\xa0在 Github 網際介面下建立倉儲時, 不要建立任何檔案, 而是在近端自行利用 git 指令建立倉儲架構, 新增內容後, 以 git remote add 設法在近端倉儲中納入 origin URL 後, 將近端倉儲版本新增提交推送到遠端 \n \n \n', 'tags': '', 'url': '建立Git倉儲.html'}, {'title': 'Git指令', 'text': 'git add \xa0 可以用來新增一個檔案, 數個檔案, 或在之前提交後所新增的所有內容 \n git commit \xa0 可以將剛剛add新增之檔案提交至遠端，在執行前須先使用 git config 建立臨時或永久的身分註記, 因為 GIT 在展開所有改版內容時, 必須明確登錄這些變更的作者與時間. \n \xa0 (1)git commit -m "改版之標題" \n git push \xa0 可以將先前改變之內容提交至指定之遠端倉儲 \n git pull \xa0 \xa0將近端改版至遠端之最新版本 \n git status\xa0\xa0 查看是否有更新的版本 \n', 'tags': '', 'url': 'Git指令.html'}, {'title': '建立Github Pages', 'text': '自行建立靜態內容管理網站 \n 利用 CMSimfly ( https://github.com/chiamingyen/cmsimfly) 內容,，將其clone至可攜系統，並利用啟動近端來編輯內容改版使遠端內容更新 \n \n', 'tags': '', 'url': '建立Github Pages.html'}, {'title': '管理網站內容', 'text': '', 'tags': '', 'url': '管理網站內容.html'}, {'title': '靜態 CMSimfly', 'text': '利用 CMSimfly (https://github.com/chiamingyen/cmsimfly) 內容, 建立自己的 Github Pages 網站 \n 設法利用 \xa0 HTML5 CSS 與 Javascript , 納入與機械設計相關的靜態網頁內容 \n 1.進入自己的倉儲資料夾 2.輸入python wsgi.py來開啟動態 3.進行改版或更新save 4.完成後按generate_pages來儲存 5.輸入git status > git add . > git commit -m "標題" > git push 6.到自己的倉儲檢查沒問題後即可 \n', 'tags': '', 'url': '靜態 CMSimfly.html'}, {'title': 'Javascript', 'text': '這裡是利用\xa0 HTML5 CSS 與 Javascript , 納入與機械設計相關的靜態網頁內容 \n', 'tags': '', 'url': 'Javascript.html'}, {'title': 'first', 'text': "Try it \n \n \n \n \n \n \n \n  Your browser doesn't support the HTML5 element canvas.      Throw dice  \n Stage:   Point:   Outcome:  \n", 'tags': '', 'url': 'first.html'}, {'title': 'canvas', 'text': '繪圖   清除 \n', 'tags': '', 'url': 'canvas.html'}, {'title': '國旗', 'text': '\n \n \n  以下利用 Brython 程式執行繪圖  \n \n \n \n \n', 'tags': '', 'url': '國旗.html'}, {'title': 'Spur Gear1', 'text': '\n \n \n \n Set Number of Gears \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n 123 \n 124 \n 125 \n 126 \n 127 \n 128 \n 129 \n 130 \n 131 \n 132 \n 133 \n 134 \n 135 \n 136 \n 137 \n 138 \n 139 \n 140 \n 141 \n 142 \n 143 \n 144 \n 145 \n 146 \n 147 \n 148 \n 149 \n 150 \n 151 \n 152 \n \n \n \n <!-- 導入 Brython 標準程式庫 --> \n <script src= "./../cmsimde/static/brython.js" ></script> \n <script src= "./../cmsimde/static/brython_stdlib.js" ></script> \n <p></p> \n <!-- 啟動 Brython --> \n <script> \n window.onload= function (){ \n // 設定 data/py 為共用程式路徑 \n brython({debug:1, pythonpath:[ \'./../data/py\' ]}); \n } \n </script> \n <p><canvas height= "600"   id= "onegear"   width= "800" ></canvas></p> \n <!-- 以下製作 button--> \n <div height= "20"   id= "onegear_div"   width= "800" ></div> \n <p><input id= "n"   type= "text"   value= "22" ><br> <button id= "button" >Set Number of Gears</button></p> \n <!-- 以下實際利用\xa0 Brython 繪圖--> \n <script type= "text/python3" > \n from browser import document as doc \n import math \n # deg 為角度轉為徑度的轉換因子 \n deg = math.pi/180. \n # 定義 Spur 類別 \n class Spur(object): \n \xa0\xa0\xa0\xa0 def __init__(self, ctx): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx = ctx \n \xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 def create_line(self, x1, y1, x2, y2, width=3, fill= "red" ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx.beginPath() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx.lineWidth = width \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx.moveTo(x1, y1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx.lineTo(x2, y2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx.strokeStyle = fill \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.ctx.stroke() \n \xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 # 定義一個繪正齒輪的繪圖函式 \n \xa0\xa0\xa0\xa0 # midx 為齒輪圓心 x 座標 \n \xa0\xa0\xa0\xa0 # midy 為齒輪圓心 y 座標 \n \xa0\xa0\xa0\xa0 # rp 為節圓半徑, n 為齒數 \n \xa0\xa0\xa0\xa0 # pa 為壓力角 (deg) \n \xa0\xa0\xa0\xa0 # rot 為旋轉角 (deg) \n \xa0\xa0\xa0\xa0 # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 \n \xa0\xa0\xa0\xa0 def Gear(self, midx, midy, rp, n=20, pa=20, color= "black" ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 齒輪漸開線分成 15 線段繪製 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 imax = 15 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.create_line(midx, midy, midx, midy-rp) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 模數也就是齒冠大小 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 a=2*rp/n \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 d=2.5*rp/n \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # ra 為齒輪的外圍半徑 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ra=rp+a \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # rb 則為齒輪的基圓半徑 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 基圓為漸開線長齒之基準圓 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rb=rp*math.cos(pa*deg) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # rd 為齒根圓半徑 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rd=rp-d \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 將圓弧分成 imax 段來繪製漸開線 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   rd>rb: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 dr = (ra-rd)/imax \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 dr=(ra-rb)/imax \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # tan(pa*deg)-pa*deg 為漸開線函數 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   j  in   range(n): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ang=-2.*j*math.pi/n+sigma \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ang2=2.*j*math.pi/n+sigma \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 lxd=midx+rd*math.sin(ang2-2.*math.pi/n) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 lyd=midy-rd*math.cos(ang2-2.*math.pi/n) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   i  in   range(imax+1): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   rd>rb: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 r=rd+i*dr \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 r=rb+i*dr \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 theta=math.sqrt((r*r)/(rb*rb)-1.) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 alpha=theta-math.atan(theta) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 xpt=r*math.sin(alpha-ang) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ypt=r*math.cos(alpha-ang) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 xd=rd*math.sin(-ang) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 yd=rd*math.cos(-ang) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # i=0 時, 繪線起點由齒根圓上的點, 作為起點 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if (i==0): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_x = midx+xd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_y = midy-yd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 最後一點, 則為齒頂圓 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if (i==imax): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 lfx=midx+xpt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 lfy=midy-ypt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_x = midx+xpt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_y = midy-ypt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # the line from last end of dedendum point to the recent \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # end of dedendum point \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 下列為齒根圓上用來近似圓弧的直線 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   i  in   range(imax+1): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   rd>rb: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 r=rd+i*dr \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 r=rb+i*dr \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 theta=math.sqrt((r*r)/(rb*rb)-1.) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 alpha=theta-math.atan(theta) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 xpt=r*math.sin(ang2-alpha) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ypt=r*math.cos(ang2-alpha) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 xd=rd*math.sin(ang2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 yd=rd*math.cos(ang2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # i=0 時, 繪線起點由齒根圓上的點, 作為起點 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if (i==0): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_x = midx+xd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_y = midy-yd \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 最後一點, 則為齒頂圓 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if (i==imax): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rfx=midx+xpt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rfy=midy-ypt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_x = midx+xpt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 last_y = midy-ypt \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 下列為齒頂圓上用來近似圓弧的直線 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 self.create_line(lfx,lfy,rfx,rfy,fill=color) \n canvas = doc[ \'onegear\' ] \n ctx = canvas.getContext( "2d" ) \n \xa0\xa0 \xa0 \n # 以 button 驅動的事件函式 \n def setgearnumber(e): \n \xa0\xa0\xa0\xa0 ctx.clearRect(0, 0, canvas.width, canvas.height) \n \xa0\xa0\xa0\xa0 x = (canvas.width)/2 \n \xa0\xa0\xa0\xa0 y = (canvas.height)/2 \n \xa0\xa0\xa0\xa0 if   doc[ "n" ].value.isdigit(): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 n1 = int(doc[ "n" ].value) \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 n1= 25 \n \xa0\xa0\xa0\xa0 # 設定齒輪參數 \n \xa0\xa0\xa0\xa0 x = (canvas.width)/2 \n \xa0\xa0\xa0\xa0 y = (canvas.height)/2 \n \xa0\xa0\xa0\xa0 r = 0.6*(canvas.height/2) \n \xa0\xa0\xa0\xa0 pa = 20 \n \xa0\xa0\xa0\xa0 # 繪出齒輪 \n \xa0\xa0\xa0\xa0 Spur(ctx).Gear(x, y, r, n1, pa,  "blue" ) \n #判定 button \n setgearnumber(True) \n doc[ \'button\' ].bind( \'click\' ,setgearnumber) \n </script> \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Spur Gear1.html'}, {'title': '解決問題', 'text': "網頁無法顯示Brython，Spur Gear 導入錯誤，案F12來開啟Console檢查錯誤。 \n 問題(一)如下圖 \n \n 解決方法: \n 開啟本倉儲資料夾，打開flaskapp.py，案ctrl+f來找到 page_content = request.form['page_content']，有2個地方都在底下加入 \n page_content = page_content.replace('// \xa0 <![CDATA[', '') \n page_content = page_content.replace('// ]]> ', '') \n \n save後即可解決問題。 \n \n \n", 'tags': '', 'url': '解決問題.html'}, {'title': 'Virtual Host', 'text': '', 'tags': '', 'url': 'Virtual Host.html'}, {'title': '架設虛擬主機', 'text': '1.google輸入ubuntu > 點選官網 > 下載 ubuntu server 2.打開virtualbox > New > 輸入名子 > 4096 MB 3.Cearte > VMDK > Dynamically > 500.00 GB 4.Sttings > Network > bridged Adapter > 進入網路中心 5.選擇電腦所使用的連接網路 > ok > Start 6.選取剛剛所下載的ubuntu > 開始 > 選取語言 7.Enter >\xa0 Enter > 輸入proxy :http://140.130.17.3:3128 8. Enter \xa0>\xa0 Enter \xa0>\xa0 Enter \xa0> continue > 全部都打一樣的 9.space >\xa0 Enter \xa0>\xa0 Enter \xa0> 再輸入帳密 > 即可開始設定 10. \xa0輸入 sudo apt install uwsgi 來安裝uwsgi \n \n \n', 'tags': '', 'url': '架設虛擬主機.html'}, {'title': '其中影片', 'text': '\n', 'tags': '', 'url': '其中影片.html'}, {'title': '期末報告', 'text': '\n  for Brython  \n \n \n  啟動 brython()  \n \n \n \n  以下利用 Brython 程式執行繪圖  \n \n \n \n \n 上述國旗繪圖程式碼: \n <!-- for Brython -->\n<script src="./../static/brython.js"></script>\n<script src="./../static/brython_stdlib.js"></script>\n<!-- 啟動 brython() -->\n<p>\n<script>\nwindow.onload=function(){\nbrython(1);\n}\n</script>\n</p>\n<!-- 以下利用 Brython 程式執行繪圖 -->\n<p><canvas height="400" id="taiwan_flag" width="600"></canvas></p>\n<p>\n<script type="text/python3">\n# 導入 doc\nfrom browser import document as doc\nimport math\n \n# 準備繪圖畫布\ncanvas = doc["taiwan_flag"]\nctx = canvas.getContext("2d")\n# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點\n# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)\n# 以下採用 canvas 原始座標繪圖\nflag_w = canvas.width\nflag_h = canvas.height\ncircle_x = flag_w/4\ncircle_y = flag_h/4\n# 先畫滿地紅\nctx.fillStyle=\'rgb(255, 0, 0)\'\nctx.fillRect(0,0,flag_w,flag_h)\n# 再畫青天\nctx.fillStyle=\'rgb(0, 0, 150)\'\nctx.fillRect(0,0,flag_w/2,flag_h/2)\n# 畫十二道光芒白日\nctx.beginPath()\nstar_radius = flag_w/8\nangle = 0\nfor i in range(24):\n    angle += 5*math.pi*2/12\n    toX = circle_x + math.cos(angle)*star_radius\n    toY = circle_y + math.sin(angle)*star_radius\n    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo\n    if (i):\n        ctx.lineTo(toX, toY)\n    else:\n        ctx.moveTo(toX, toY)\nctx.closePath()\n# 將填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n# 白日:藍圈\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為藍色\nctx.fillStyle = \'rgb(0, 0, 149)\'\nctx.fill()\n# 白日:白心\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n</script> \n', 'tags': '', 'url': '期末報告.html'}]};