var tipuesearch = {"pages": [{'title': '期中影片', 'text': '', 'tags': '', 'url': '期中影片.html'}, {'title': '網路連線設定', 'text': '\n 了解機械設計系電腦輔助設計室電腦的網路設定, 其中包括 IPv4 網路與 IPv6 網路設定.', 'tags': '', 'url': '網路連線設定.html'}, {'title': '配置可攜程式環境', 'text': '取得 Windows 10 64 位元環境下的可攜程式環境  ( 下載\xa0 2019_cdb_w5.7z ), 下載後解開目錄, 放入 USB3.0 規格以上的隨身碟或隨身硬碟. \n 開啟start.bat即可以開啟隨身系統，以開啟stop.bat結束隨身系統 \n Y:\xa0 即切換至Y槽 \n cd ___\xa0 \xa0 切換至某目錄 \n cd ..\xa0 回至上一層目錄 \n cd / 回至目前所在槽 \n dir\xa0 \xa0列出目前所在目錄的內容 \n mkdir\xa0 在所在位置建立目錄 \n cls\xa0\xa0 清除目前的命令列顯示的內容 \n', 'tags': '', 'url': '配置可攜程式環境.html'}, {'title': '建立Git倉儲', 'text': '\n 建立 Git 倉儲, 共分為兩類 \n (1)\xa0 直接在 Github 網際介面下建立倉儲時, 要求建立 README.md 檔案, 之後可以直接在近端, 以 git clone 加上倉儲連線 URL, 將倉儲克隆一份到近端, 並以最新版本作為工作目錄, 使用者改版後, 可以直接透過 git add, commit 與 push 對遠端倉儲改版 \n \n (2)\xa0\xa0在 Github 網際介面下建立倉儲時, 不要建立任何檔案, 而是在近端自行利用 git 指令建立倉儲架構, 新增內容後, 以 git remote add 設法在近端倉儲中納入 origin URL 後, 將近端倉儲版本新增提交推送到遠端 \n \n', 'tags': '', 'url': '建立Git倉儲.html'}, {'title': 'Git指令', 'text': 'git add \xa0 可以用來新增一個檔案, 數個檔案, 或在之前提交後所新增的所有內容 \n git commit \xa0 可以將剛剛add新增之檔案提交至遠端，在執行前須先使用 git config 建立臨時或永久的身分註記, 因為 GIT 在展開所有改版內容時, 必須明確登錄這些變更的作者與時間. \n \xa0 (1)git commit -m "改版之標題" \n git push \xa0 可以將先前改變之內容提交至指定之遠端倉儲 \n git pull \xa0 \xa0將近端改版至遠端之最新版本', 'tags': '', 'url': 'Git指令.html'}, {'title': '建立Github Pages', 'text': '自行建立靜態內容管理網站 \n 利用 CMSimfly ( https://github.com/chiamingyen/cmsimfly) 內容,，將其clone至可攜系統，並利用啟動近端來編輯內容改版使遠端內容更新 \n', 'tags': '', 'url': '建立Github Pages.html'}, {'title': '管理網站內容', 'text': '', 'tags': '', 'url': '管理網站內容.html'}, {'title': '測試', 'text': "Try it \n \n \n \n \n \n \n \n  Your browser doesn't support the HTML5 element canvas.      Throw dice  \n Stage:   Point:   Outcome:  \n", 'tags': '', 'url': '測試.html'}, {'title': '測試-2', 'text': " Your browser doesn't support the HTML5 element canvas.  \n \n 繪圖   清除 \n", 'tags': '', 'url': '測試-2.html'}, {'title': '國旗', 'text': '使用  Brython  繪圖: \n  導入 Brython 標準程式庫  \n \n \n \n  啟動 Brython  \n \n \n \n  以下製作 button \n \n   Set Number of Gears \n  以下實際利用  Brython 繪圖 \n \n 上述正齒輪繪圖程式碼: \n <!-- 導入 Brython 標準程式庫 -->\n<script src="./../static/brython.js"></script>\n<script src="./../static/brython_stdlib.js"></script>\n<p></p>\n<!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\n// 設定 data/py 為共用程式路徑\nbrython({debug:1, pythonpath:[\'./../data/py\']});\n}\n</script>\n<p><canvas height="600" id="onegear" width="800"></canvas></p>\n<!-- 以下製作 button-->\n<div height="20" id="onegear_div" width="800"></div>\n<p><input id="n" type="text" value="22"><br> <button id="button">Set Number of Gears</button></p>\n<!-- 以下實際利用  Brython 繪圖-->\n<script type="text/python3">\nfrom browser import document as doc\nimport math\n# deg 為角度轉為徑度的轉換因子\ndeg = math.pi/180.\n# 定義 Spur 類別\nclass Spur(object):\n    def __init__(self, ctx):\n        self.ctx = ctx\n \n    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):\n        self.ctx.beginPath()\n        self.ctx.lineWidth = width\n        self.ctx.moveTo(x1, y1)\n        self.ctx.lineTo(x2, y2)\n        self.ctx.strokeStyle = fill\n        self.ctx.stroke()\n \n    # 定義一個繪正齒輪的繪圖函式\n    # midx 為齒輪圓心 x 座標\n    # midy 為齒輪圓心 y 座標\n    # rp 為節圓半徑, n 為齒數\n    # pa 為壓力角 (deg)\n    # rot 為旋轉角 (deg)\n    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷\n    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):\n        # 齒輪漸開線分成 15 線段繪製\n        imax = 15\n        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線\n        self.create_line(midx, midy, midx, midy-rp)\n        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數\n        # 模數也就是齒冠大小\n        a=2*rp/n\n        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍\n        d=2.5*rp/n\n        # ra 為齒輪的外圍半徑\n        ra=rp+a\n        # rb 則為齒輪的基圓半徑\n        # 基圓為漸開線長齒之基準圓\n        rb=rp*math.cos(pa*deg)\n        # rd 為齒根圓半徑\n        rd=rp-d\n        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd\n        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小\n        # 將圓弧分成 imax 段來繪製漸開線\n        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd\n        if rd>rb:\n            dr = (ra-rd)/imax\n        else:\n            dr=(ra-rb)/imax\n        # tan(pa*deg)-pa*deg 為漸開線函數\n        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg\n        for j in range(n):\n            ang=-2.*j*math.pi/n+sigma\n            ang2=2.*j*math.pi/n+sigma\n            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)\n            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)\n            for i in range(imax+1):\n                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd\n                if rd>rb:\n                    r=rd+i*dr\n                else:\n                    r=rb+i*dr\n                theta=math.sqrt((r*r)/(rb*rb)-1.)\n                alpha=theta-math.atan(theta)\n                xpt=r*math.sin(alpha-ang)\n                ypt=r*math.cos(alpha-ang)\n                xd=rd*math.sin(-ang)\n                yd=rd*math.cos(-ang)\n                # i=0 時, 繪線起點由齒根圓上的點, 作為起點\n                if(i==0):\n                    last_x = midx+xd\n                    last_y = midy-yd\n                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點\n                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)\n                # 最後一點, 則為齒頂圓\n                if(i==imax):\n                    lfx=midx+xpt\n                    lfy=midy-ypt\n                last_x = midx+xpt\n                last_y = midy-ypt\n            # the line from last end of dedendum point to the recent\n            # end of dedendum point\n            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標\n            # 下列為齒根圓上用來近似圓弧的直線\n            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)\n            for i in range(imax+1):\n                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd\n                if rd>rb:\n                    r=rd+i*dr\n                else:\n                    r=rb+i*dr\n                theta=math.sqrt((r*r)/(rb*rb)-1.)\n                alpha=theta-math.atan(theta)\n                xpt=r*math.sin(ang2-alpha)\n                ypt=r*math.cos(ang2-alpha)\n                xd=rd*math.sin(ang2)\n                yd=rd*math.cos(ang2)\n                # i=0 時, 繪線起點由齒根圓上的點, 作為起點\n                if(i==0):\n                    last_x = midx+xd\n                    last_y = midy-yd\n                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點\n                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)\n                # 最後一點, 則為齒頂圓\n                if(i==imax):\n                    rfx=midx+xpt\n                    rfy=midy-ypt\n                last_x = midx+xpt\n                last_y = midy-ypt\n            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標\n            # 下列為齒頂圓上用來近似圓弧的直線\n            self.create_line(lfx,lfy,rfx,rfy,fill=color)\ncanvas = doc[\'onegear\']\nctx = canvas.getContext("2d")\n \n# 以 button 驅動的事件函式\ndef setgearnumber(e):\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    x = (canvas.width)/2\n    y = (canvas.height)/2\n    if doc["n"].value.isdigit():\n        n1 = int(doc["n"].value)\n    else:\n        n1= 25\n    # 設定齒輪參數\n    x = (canvas.width)/2\n    y = (canvas.height)/2\n    r = 0.6*(canvas.height/2)\n    pa = 20\n    # 繪出齒輪\n    Spur(ctx).Gear(x, y, r, n1, pa, "blue")\n#判定 button\nsetgearnumber(True)\ndoc[\'button\'].bind(\'click\',setgearnumber)\n</script> \n \n', 'tags': '', 'url': '國旗.html'}, {'title': '架設虛擬主機', 'text': '', 'tags': '', 'url': '架設虛擬主機.html'}, {'title': '期末報告', 'text': '\n  for Brython  \n \n \n  啟動 brython()  \n \n \n \n  以下利用 Brython 程式執行繪圖  \n \n \n \n \n 上述國旗繪圖程式碼: \n <!-- for Brython -->\n<script src="./../static/brython.js"></script>\n<script src="./../static/brython_stdlib.js"></script>\n<!-- 啟動 brython() -->\n<p>\n<script>\nwindow.onload=function(){\nbrython(1);\n}\n</script>\n</p>\n<!-- 以下利用 Brython 程式執行繪圖 -->\n<p><canvas height="400" id="taiwan_flag" width="600"></canvas></p>\n<p>\n<script type="text/python3">\n# 導入 doc\nfrom browser import document as doc\nimport math\n \n# 準備繪圖畫布\ncanvas = doc["taiwan_flag"]\nctx = canvas.getContext("2d")\n# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點\n# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)\n# 以下採用 canvas 原始座標繪圖\nflag_w = canvas.width\nflag_h = canvas.height\ncircle_x = flag_w/4\ncircle_y = flag_h/4\n# 先畫滿地紅\nctx.fillStyle=\'rgb(255, 0, 0)\'\nctx.fillRect(0,0,flag_w,flag_h)\n# 再畫青天\nctx.fillStyle=\'rgb(0, 0, 150)\'\nctx.fillRect(0,0,flag_w/2,flag_h/2)\n# 畫十二道光芒白日\nctx.beginPath()\nstar_radius = flag_w/8\nangle = 0\nfor i in range(24):\n    angle += 5*math.pi*2/12\n    toX = circle_x + math.cos(angle)*star_radius\n    toY = circle_y + math.sin(angle)*star_radius\n    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo\n    if (i):\n        ctx.lineTo(toX, toY)\n    else:\n        ctx.moveTo(toX, toY)\nctx.closePath()\n# 將填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n# 白日:藍圈\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為藍色\nctx.fillStyle = \'rgb(0, 0, 149)\'\nctx.fill()\n# 白日:白心\nctx.beginPath()\nctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)\nctx.closePath()\n# 填色設為白色\nctx.fillStyle = \'#fff\'\nctx.fill()\n</script> \n', 'tags': '', 'url': '期末報告.html'}]};