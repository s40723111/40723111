<h1>網路連線設定</h1>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/mBNL7XV1Gq4" width="560"></iframe></p>
<p><span>了解機械設計系電腦輔助設計室電腦的網路設定, 其中包括 IPv4 網路與 IPv6 網路設定.</span></p>
<h1>配置可攜程式環境</h1>
<p><span>取得 Windows 10 64 位元環境下的可攜程式環境 </span><span>(</span><a href="https://drive.google.com/file/d/1_TQBw1PM7jxrmtsBjvLKbjJWfGs8Ug79/view">下載  2019_cdb_w5.7z</a><span>), 下載後解開目錄, 放入 USB3.0 規格以上的隨身碟或隨身硬碟.</span></p>
<p>開啟start.bat即可以開啟隨身系統，以開啟stop.bat結束隨身系統</p>
<p>Y:  即切換至Y槽</p>
<p>cd ___    切換至某目錄</p>
<p>cd ..  回至上一層目錄</p>
<p>cd / 回至目前所在槽</p>
<p><span>dir   列出目前所在目錄的內容</span></p>
<p><span>mkdir  在所在位置建立目錄</span></p>
<p>cls  <span>清除目前的命令列顯示的內容</span></p>
<p></p>
<h1>建立Git倉儲</h1>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9xdKNc7-CeI" width="560"></iframe></p>
<p><span>建立 Git 倉儲, 共分為兩類</span></p>
<p><span>(1)  直接在 Github 網際介面下建立倉儲時, 要求建立 README.md 檔案, 之後可以直接在近端, 以 git clone 加上倉儲連線 URL, 將倉儲克隆一份到近端, 並以最新版本作為工作目錄, 使用者改版後, 可以直接透過 git add, commit 與 push 對遠端倉儲改版</span></p>
<p><span><img alt="" src="https://mdecp2018.github.io/site-s40723123/images/create%20repository(with%20README).JPG" width="650"/></span></p>
<p><span>(2)  在 Github 網際介面下建立倉儲時, 不要建立任何檔案, 而是在近端自行利用 git 指令建立倉儲架構, 新增內容後, 以 git remote add 設法在近端倉儲中納入 origin URL 後, 將近端倉儲版本新增提交推送到遠端</span></p>
<p><span><img alt="" height="483" src="https://mdecp2018.github.io/site-s40723123/images/create%20repository.JPG" width="644"/></span></p>
<p><span><img alt="" height="395" src="https://mdecp2018.github.io/site-s40723123/images/create%20repository(set%20by%20self).JPG" width="650"/></span></p>
<h1>Git指令</h1>
<p><strong>git add<span> </span></strong><span>可以用來新增一個檔案, 數個檔案, 或在之前提交後所新增的所有內容</span></p>
<p><span><strong>git commit<span> </span></strong>可以將剛剛add新增之檔案提交至遠端，在執行前須先使用 git config 建立臨時或永久的身分註記, 因為 GIT 在展開所有改版內容時, 必須明確登錄這些變更的作者與時間.<br/></span></p>
<p><span>  (1)git commit -m "改版之標題"</span></p>
<p><strong>git push</strong><span> </span>可以將先前改變之內容提交至指定之遠端倉儲</p>
<p><strong>git pull</strong>   將近端改版至遠端之最新版本</p>
<p><strong>git status  </strong>查看是否有更新的版本</p>
<h1>建立Github Pages</h1>
<p><span>自行建立靜態內容管理網站</span></p>
<p>利用 CMSimfly (<a href="https://github.com/chiamingyen/cmsimfly">https://github.com/chiamingyen/cmsimfly)</a>內容,，將其clone至可攜系統，並利用啟動近端來編輯內容改版使遠端內容更新</p>
<p><img alt="" height="386" src="https://mdecp2018.github.io/site-s40723123/images/clone%20URL.JPG" width="650"/></p>
<h1>倉儲改版</h1>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9ZSdj-UFpV4" width="560"></iframe></p>
<p></p><h1>靜態 CMSimfly</h1>
<p>利用 CMSimfly (https://github.com/chiamingyen/cmsimfly) 內容, 建立自己的 Github Pages 網站</p>
<p><br/>設法利用<span> </span><a href="http://mde.tw/wcm2019/content/%E5%AF%A6%E7%BF%92%E9%A0%85%E7%9B%AE%E4%B8%89.html">HTML5 CSS 與 Javascript</a>, 納入與機械設計相關的靜態網頁內容</p>
<p><span>1.進入自己的倉儲資料夾</span><br/><span><br/></span><span></span><span>2.輸入python wsgi.py來開啟動態</span><br/><span><br/></span><span></span><span>3.進行改版或更新save</span><br/><span><br/></span><span></span><span>4.完成後按generate_pages來儲存</span><br/><span><br/></span><span></span><span>5.輸入git status &gt; git add . &gt; git commit -m "標題" &gt; git push</span><br/><span><br/></span><span></span><span>6.到自己的倉儲檢查沒問題後即可</span></p>
<h1>Javascript</h1>
<p><span>這裡是利用 </span><a href="http://mde.tw/wcm2019/content/%E5%AF%A6%E7%BF%92%E9%A0%85%E7%9B%AE%E4%B8%89.html">HTML5 CSS 與 Javascript</a><span>, 納入與機械設計相關的靜態網頁內容</span></p>
<h2>first</h2>
<p><button onclick="myFunction()">Try it</button></p>
<p id="demo"></p>
<pre class="brush: py">
<script>
function myFunction() {
  document.getElementById("demo").innerHTML = Math.floor(Math.random()*10);
}
</script>
</pre>
<p>
<script type="text/javascript">
var cwidth = 400;
    var cheight = 300;
    var dicex = 50;
    var dicey = 50;
    var dicewidth = 100;
    var diceheight = 100;
    var dotrad = 6;
    var ctx;
    var dx;
    var dy;
    var firstturn = true;
    var point;
function throwdice() {
    var sum;
    var ch = 1+Math.floor(Math.random()*6);
    sum = ch;
    dx = dicex;
    dy = dicey;
    drawface(ch);
    dx = dicex + 150;
    ch=1 + Math.floor(Math.random()*6);
    sum += ch;
    drawface(ch);
    if (firstturn) {
        switch(sum) {
            case 7:
            case 11:
              document.f.outcome.value="You win!";
              break;
            case 2:
            case 3:
            case 12:
              document.f.outcome.value="You lose!";
              break;
            default:
              point = sum;
              document.f.pv.value=point;
              firstturn = false;
              document.f.stage.value="Need follow-up throw.";
              document.f.outcome.value="   ";
        }
    }
    else {
        switch(sum) {
        case point:
           document.f.outcome.value="You win!";
           document.f.stage.value="Back to first throw.";
           document.f.pv.value=" ";
           firstturn = true;
           break;
        case 7:
           document.f.outcome.value="You lose!";
           document.f.stage.value="Back to first throw.";
           document.f.pv.value=" ";
           firstturn = true;
        }
            }
}
function drawface(n) {
  ctx = document.getElementById('canvas').getContext('2d');  
  ctx.lineWidth = 5;
  ctx.clearRect(dx,dy,dicewidth,diceheight);
  ctx.strokeRect(dx,dy,dicewidth,diceheight)
  var dotx;
  var doty;
  ctx.fillStyle = "#009966";
    switch(n) {
        case 1:
         draw1();
         break;
        case 2:
         draw2();
         break;
        case 3:
         draw2();
         draw1();
         break;
        case 4:
         draw4();
         break;
        case 5:
         draw4();
         draw1();
         break;
        case 6:
         draw4();
         draw2mid();
         break;
         
    }
}
function draw1() {
    var dotx;
    var doty;
    ctx.beginPath();
    dotx = dx + .5*dicewidth;
    doty = dy + .5*diceheight;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    ctx.closePath();
    ctx.fill();
}
function draw2() {
    var dotx;
    var doty;
    ctx.beginPath();
    dotx = dx + 3*dotrad;
    doty = dy + 3*dotrad;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    dotx = dx+dicewidth-3*dotrad;
    doty = dy+diceheight-3*dotrad;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    ctx.closePath();
    ctx.fill();
}
function draw4() {
    var dotx;
    var doty;
    ctx.beginPath();
    dotx = dx + 3*dotrad;
    doty = dy + 3*dotrad;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    dotx = dx+dicewidth-3*dotrad;
    doty = dy+diceheight-3*dotrad;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    dotx = dx + 3*dotrad;
    doty = dy + diceheight-3*dotrad;  //no change
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    dotx = dx+dicewidth-3*dotrad;
    doty = dy+ 3*dotrad;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    ctx.closePath();
    ctx.fill(); 
}
function draw2mid() {
    var dotx;
    var doty;
    ctx.beginPath();
    dotx = dx + 3*dotrad;
    doty = dy + .5*diceheight;
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    dotx = dx+dicewidth-3*dotrad;
    doty = dy + .5*diceheight; //no change
    ctx.arc(dotx,doty,dotrad,0,Math.PI*2,true);
    ctx.closePath();
    ctx.fill();
}
</script>
</p>
<p><canvas height="300" id="canvas" width="400"> Your browser doesn't support the HTML5 element canvas. </canvas> <br/> <button onclick="throwdice();">Throw dice </button></p>
<form id="f" name="f">Stage: <input name="stage" type="text" value="First Throw"/> Point: <input name="pv" type="text" value="   "/> Outcome: <input name="outcome" type="text" value="     "/></form>
<h2>canvas</h2>
<p><canvas height="300" id="canvas" width="400"> Your browser doesn't support the HTML5 element canvas. </canvas></p>
<script>
canvas = document.getElementById("canvas");
ctx = canvas.getContext('2d');
  
function draw(){
 ctx.beginPath();
 ctx.strokeStyle = "rgb(200,0,0)";
 ctx.arc(200, 200,50,0,2*Math.PI, false);
 ctx.closePath();
 ctx.stroke();
}
  
function clear_canvas(){
// Store the current transformation matrix
// The save() method pushes the current state onto the stack..
ctx.save();
  
// Use the identity matrix while clearing the canvas
// the setTransform() method lets you scale, rotate, move, and skew the current context.
// setTransform(Horizontal scaling, Horizontal skewing,Vertical skewing, Vertical scaling, Horizontal moving, Vertical moving)
ctx.setTransform(1, 0, 0, 1, 0, 0);
ctx.clearRect(0, 0, canvas.width, canvas.height);
// Restore the transform
// The restore() method pops the top state on the stack, restoring the context to that state.
ctx.restore();
}
</script>
<p><button onclick="draw()">繪圖</button> <button onclick="clear_canvas()">清除</button></p>
<h2>國旗</h2>
<!-- for Brython -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 brython() -->
<p>
<script>
window.onload=function(){
brython(1);
}
</script>
</p>
<!-- 以下利用 Brython 程式執行繪圖 -->
<p><canvas height="400" id="taiwan_flag" width="600"></canvas></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- for Brython --&gt;
&lt;script src="./../static/brython.js"&gt;&lt;/script&gt;
&lt;script src="./../static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;p&gt;
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;
&lt;/p&gt;
&lt;!-- 以下利用 Brython 程式執行繪圖 --&gt;
&lt;p&gt;&lt;canvas height="400" id="taiwan_flag" width="600"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/python3"&gt;
# 導入 doc
from browser import document as doc
import math
 
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
&lt;/script&gt;</pre>
<p></p>
<p>
<script type="text/python3">
# 導入 doc
from browser import document as doc
import math
   
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
</script>
</p>
<h2>國旗-2</h2>
<!-- for Brython -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 brython() -->
<p>
<script>
window.onload=function(){
brython(1);
}
</script>
</p>
<!-- 以下利用 Brython 程式執行繪圖 -->
<p><canvas height="400" id="taiwan_flag" width="600">&lt;!-- for Brython --&gt;<br/>&lt;script src="/static/brython.js"&gt;&lt;/script&gt;<br/>&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;<br/>&lt;!-- 啟動 brython() --&gt;<br/>&lt;p&gt;<br/>&lt;script&gt;// &lt;![CDATA[<br/>window.onload=function(){<br/>brython(1);<br/>}<br/>// ]]&gt;&lt;/script&gt;<br/>&lt;/p&gt;<br/>&lt;!-- 以下利用 Brython 程式執行繪圖 --&gt;<br/>&lt;p&gt;&lt;canvas height="400" id="taiwan_flag" width="600"&gt;&lt;/canvas&gt;&lt;/p&gt;<br/>&lt;p&gt;<br/>&lt;script type="text/python3"&gt;// &lt;![CDATA[<br/># 導入 doc<br/>from browser import document as doc<br/>import math<br/> <br/># 準備繪圖畫布<br/>canvas = doc["taiwan_flag"]<br/>ctx = canvas.getContext("2d")<br/># 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點<br/># ctx.setTransform(1, 0, 0, -1, 0, canvas.height)<br/># 以下採用 canvas 原始座標繪圖<br/>flag_w = canvas.width<br/>flag_h = canvas.height<br/>circle_x = flag_w/2<br/>circle_y = flag_h/2<br/># 先畫滿地青天<br/>ctx.fillStyle='#00FFFF'<br/>ctx.fillRect(0,0,flag_w,flag_h)<br/># 再畫紫天<br/>ctx.fillStyle='#9400D3'<br/>ctx.fillRect(flag_w/3,flag_h/4,200,200)<br/># 畫十二道光芒白日<br/>ctx.beginPath()<br/>star_radius = flag_w/8<br/>angle = 0<br/>for i in range(24):<br/> angle += 5*math.pi*2/12<br/> toX = circle_x + math.cos(angle)*star_radius<br/> toY = circle_y + math.sin(angle)*star_radius<br/> # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo<br/> if (i):<br/> ctx.lineTo(toX, toY)<br/> else:<br/> ctx.moveTo(toX, toY)<br/>ctx.closePath()<br/># 將填色設為白色<br/>ctx.fillStyle = '#fff'<br/>ctx.fill()<br/># 白日:藍圈<br/>ctx.beginPath()<br/>ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)<br/>ctx.closePath()<br/># 填色設為綠色<br/>ctx.fillStyle = '#00FF7F'<br/>ctx.fill()<br/># 白日:白心<br/>ctx.beginPath()<br/>ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)<br/>ctx.closePath()<br/># 填色設為白色<br/>ctx.fillStyle = '#fff'<br/>ctx.fill()<br/>// ]]&gt;&lt;/script&gt;<br/>&lt;/p&gt;</canvas></p>
<p></p>
<p>
<script type="text/python3">
# 導入 doc
from browser import document as doc
import math
   
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/2
circle_y = flag_h/2
# 先畫滿地青天
ctx.fillStyle='#00FFFF'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫紫天
ctx.fillStyle='#9400D3'
ctx.fillRect(flag_w/3,flag_h/4,200,200)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為綠色
ctx.fillStyle = '#00FF7F'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
</script>
</p>
<h2>Spur Gear1</h2>
<!-- 導入 Brython 標準程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<p></p>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
</script>
<p><canvas height="600" id="onegear" width="800"></canvas></p>
<!-- 以下製作 button-->
<div height="20" id="onegear_div" width="800"></div>
<p><input id="n" type="text" value="22"/><br/> <button id="button">Set Number of Gears</button></p>
<!-- 以下實際利用  Brython 繪圖-->
<script type="text/python3">
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx
   
    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
   
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd>rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd>rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd>rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")
   
# 以 button 驅動的事件函式
def setgearnumber(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["n"].value.isdigit():
        n1 = int(doc["n"].value)
    else:
        n1= 25
    # 設定齒輪參數
    x = (canvas.width)/2
    y = (canvas.height)/2
    r = 0.6*(canvas.height/2)
    pa = 20
    # 繪出齒輪
    Spur(ctx).Gear(x, y, r, n1, pa, "blue")
#判定 button
setgearnumber(True)
doc['button'].bind('click',setgearnumber)
</script>
<h1>解決問題</h1>
<p>網頁無法顯示Brython，Spur Gear 導入錯誤，案F12來開啟Console檢查錯誤。</p>
<p>問題(一)如下圖</p>
<p><img caption="false" height="445" src="https://s40723210.github.io/40723210/images/chrome_rg3IpZC7Gr.png" width="650"/></p>
<p>解決方法:</p>
<p>開啟本倉儲資料夾，打開flaskapp.py，案ctrl+f來找到<span>page_content = request.form['page_content']，有2個地方都在底下加入</span></p>
<div class="line number1 index0 alt2"><code class="html plain">page_content = page_content.replace('//<span> </span></code><code class="html color2">&lt;![CDATA[', '')</code></div>
<div class="line number2 index1 alt1"><code class="html color2">page_content = page_content.replace('// ]]&gt;</code><code class="html plain">', '')<br/><br/></code></div>
<div class="line number2 index1 alt1"><code class="html plain"></code></div>
<div class="line number2 index1 alt1"><code class="html plain">save後即可解決問題。</code></div>
<div class="line number2 index1 alt1"><code class="html plain"><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/24j4m5LRPY8" width="560"></iframe></code></div>
<div class="line number2 index1 alt1"><code class="html plain"></code></div>
<h1>Virtual Host</h1>
<p>Fossil SCM<br/><br/>如何利用 Fossil SCM, 在 Virtualbox 中的 Ubuntu 18.04-2 (8.5 GB) 建立類似 Github 的系統, 可以放入 CMSimfly 的靜態網頁<br/><br/>Ubuntu 18.04 (https://www.ubuntu.com/about/release-cycle), 配置網路連線, 然後架構 uwsgi 環境下的 CMSimfly 動態網站, 或建立 Fossil SCM 用來伺服管理 CMSimfly 下有版次管理的靜態網頁, 或利用 nginx 伺服無版次管理的 CMSimfly 靜態網頁.</p>
<h2>架設虛擬主機</h2>
<p><span>1.google輸入ubuntu &gt; 點選官網 &gt; 下載</span><span>ubuntu server</span><br/><span><br/></span><span></span><span>2.打開virtualbox &gt; New &gt; 輸入名子 &gt; 4096 MB</span><br/><span><br/></span><span></span><span>3.Cearte &gt; VMDK &gt; Dynamically &gt; 500.00 GB</span><br/><span><br/></span><span></span><span>4.Sttings &gt; Network &gt; bridged Adapter &gt; 進入網路中心</span><br/><br/><span>5.選擇電腦所使用的連接網路 &gt; ok &gt; Start</span><br/><span><br/></span><span></span><span>6.選取剛剛所下載的ubuntu &gt; 開始 &gt; 選取語言</span><br/><br/><span>7.Enter &gt; </span><span>Enter &gt; 輸入proxy :http://140.130.17.3:3128</span><br/><span><br/></span><span></span><span>8.</span><span>Enter</span><span> &gt; </span><span>Enter</span><span> &gt; </span><span>Enter</span><span> &gt; continue &gt; 全部都打一樣的</span><br/><span><br/></span><span></span><span>9.space &gt; </span><span>Enter</span><span> &gt; </span><span>Enter</span><span> &gt; 再輸入帳密 &gt; 即可開始設定</span><br/><br/><span>10.<span> 輸入</span><span>sudo apt install uwsgi 來安裝uwsgi</span></span></p>
<p></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ZtOK_dafs50" width="560"></iframe></p>
<h1>期中影片</h1>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/0IoCMM3iR8g" width="560"></iframe></p>
<h1>期末報告</h1>
<p>這是我的期末影片</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/8DVgka3JTwM" width="560"></iframe></p>
<p><strong></strong></p>
<!-- for Brython -->
<script src="/get_page/static/brython.js"></script>
<script src="/get_page/static/brython_stdlib.js"></script>
<!-- 啟動 brython() -->
<p>
<script>
window.onload=function(){
brython(1);
}
</script>
</p>
<!-- 以下利用 Brython 程式執行繪圖 -->
<p><canvas height="400" id="taiwan_flag" width="600"></canvas></p>
<p>
<script type="text/python3">
# 導入 doc
from browser import document as doc
import math
 
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
</script>
</p>
<p></p>
<p></p>